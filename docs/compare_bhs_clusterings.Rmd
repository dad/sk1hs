---
title: "BHS Clustering Comparison"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    self_contained: true
    fig_width: 10
    fig_height: 8
params:
  clustering_a: "results/bhs_clusters_rep1.tsv"
  clustering_b: "results/bhs_clusters_rep2.tsv"
  label_a: "Clustering A"
  label_b: "Clustering B"
  annotations: "data/processed/yeast_ORF_TPM_matrix_labeled_with_categories.csv"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, warning = FALSE, message = FALSE,
  fig.retina = 2, dpi = 150
)
project_root <- normalizePath(file.path(dirname(
  knitr::current_input(dir = TRUE)
), ".."))
```

## Setup

```{r libraries}
library(dplyr)
library(tidyr)
library(readr)
library(ggplot2)
library(ggrepel)
library(patchwork)
library(scales)
library(ggraph)
library(tidygraph)
library(gt)
library(ggalluvial)
library(aricode)
```

```{r config}
# --- Colour palette (shared with bhs_clustering.Rmd) --------------------
enrich_levels  <- c("Hsf1 target", "Msn2 target", "Hac1 target",
                    "RPG", "RiBi gene", "Rpn4 target", "Gcn4 target",
                    "Sum1 target", "---")
enrich_colours <- c(
  "Hsf1 target" = "#d62728", "Msn2 target" = "#ff7f0e",
  "Hac1 target" = "#9467bd", "RPG"         = "#1f77b4",
  "RiBi gene"   = "#2ca02c", "Rpn4 target" = "#e377c2",
  "Gcn4 target" = "#8c564b", "Sum1 target" = "#bcbd22",
  "---"         = "grey70"
)
```

```{r load-data}
# --- Load clusterings ----------------------------------------------------
clust_a <- read_tsv(file.path(project_root, params$clustering_a),
                    show_col_types = FALSE)
clust_b <- read_tsv(file.path(project_root, params$clustering_b),
                    show_col_types = FALSE)

# --- Load annotations (optional) -----------------------------------------
ann_path <- file.path(project_root, params$annotations)
has_annotations <- file.exists(ann_path)

if (has_annotations) {
  cats <- read_csv(ann_path, show_col_types = FALSE) |>
    select(systematic_name, common_name, gene_category)

  # Additional gene lists
  read_genelist <- function(fname) {
    lines <- readLines(file.path(project_root, "data", "info", fname))
    lines[!grepl("^#|^$", lines)]
  }
  ribi <- read_genelist("ribi_genes.txt")
  rpn4 <- read_genelist("Rpn4_target_genes.txt")
  gcn4 <- read_genelist("gcn4_target_genes.txt")
  sum1 <- read_genelist("sum1_target_genes.txt")
} else {
  cats <- clust_a |>
    select(systematic_name) |>
    mutate(common_name = systematic_name, gene_category = "other")
}

# --- Join the two clusterings on shared genes ----------------------------
combined <- inner_join(
  clust_a |> rename(cluster_a = cluster_id),
  clust_b |> rename(cluster_b = cluster_id),
  by = "systematic_name"
) |>
  left_join(cats, by = "systematic_name")

n_shared  <- nrow(combined)
n_only_a  <- sum(!clust_a$systematic_name %in% clust_b$systematic_name)
n_only_b  <- sum(!clust_b$systematic_name %in% clust_a$systematic_name)
```

**`r params$label_a`**: `r n_distinct(clust_a$cluster_id)` clusters,
`r nrow(clust_a)` genes.
**`r params$label_b`**: `r n_distinct(clust_b$cluster_id)` clusters,
`r nrow(clust_b)` genes.
**Shared genes**: `r n_shared`
`r if (n_only_a > 0 || n_only_b > 0) paste0("(", n_only_a, " only in A, ", n_only_b, " only in B)") else "(complete overlap)."`


```{r helper-functions}
# =========================================================================
# Reusable helpers (extracted from bhs_clustering.Rmd)
# =========================================================================

build_bhs_tree <- function(cluster_df, annotations,
                           extra_lists = NULL) {

  # Merge annotations
  clust <- cluster_df |>
    left_join(annotations, by = "systematic_name")

  # --- Enrichment: gene_category terms -----------------------------------
  enrich_cat <- clust |>
    filter(gene_category != "other") |>
    count(cluster_id, gene_category, name = "k") |>
    left_join(clust |> count(cluster_id, name = "n_cluster"),
              by = "cluster_id") |>
    mutate(
      K = sapply(gene_category, \(gc) sum(clust$gene_category == gc)),
      N = nrow(clust),
      fold = (k / n_cluster) / (K / N),
      pval = mapply(\(k, n, K, N) {
        fisher.test(matrix(c(k, n - k, K - k, N - K - n + k), 2, 2),
                    alternative = "greater")$p.value
      }, k, n_cluster, K, N)
    )

  # --- Enrichment: additional gene lists ---------------------------------
  enrich_extra <- NULL
  if (!is.null(extra_lists)) {
    test_list <- function(gene_vec, label) {
      clust |>
        mutate(hit = common_name %in% gene_vec) |>
        group_by(cluster_id) |>
        summarise(k = sum(hit), n_cluster = n(), .groups = "drop") |>
        filter(k > 0) |>
        mutate(
          gene_category = label,
          K = sum(clust$common_name %in% gene_vec),
          N = nrow(clust),
          fold = (k / n_cluster) / (K / N),
          pval = mapply(\(k, n, K, N) {
            fisher.test(matrix(c(k, n - k, K - k, N - K - n + k), 2, 2),
                        alternative = "greater")$p.value
          }, k, n_cluster, K, N)
        )
    }
    enrich_extra <- bind_rows(lapply(names(extra_lists), \(nm) {
      test_list(extra_lists[[nm]], nm)
    }))
  }

  all_enrich <- bind_rows(enrich_cat, enrich_extra) |>
    filter(pval < 0.05) |>
    group_by(cluster_id) |>
    slice_min(pval, n = 1, with_ties = FALSE) |>
    ungroup()

  # --- Cluster summary ---------------------------------------------------
  cluster_summary <- clust |>
    count(cluster_id, name = "n") |>
    arrange(cluster_id) |>
    left_join(all_enrich |> select(cluster_id, enrichment = gene_category,
                                    fold, pval),
              by = "cluster_id") |>
    mutate(
      depth = nchar(gsub("[^.]", "", cluster_id)) + 1L,
      enrichment = coalesce(enrichment, "---")
    )

  # --- Tree reconstruction -----------------------------------------------
  leaf_paths <- sort(unique(cluster_summary$cluster_id))
  all_nodes  <- "ROOT"
  for (p in leaf_paths) {
    parts <- strsplit(p, "\\.")[[1]]
    for (i in seq_along(parts))
      all_nodes <- c(all_nodes, paste(parts[1:i], collapse = "."))
  }
  all_nodes <- unique(all_nodes)

  edges <- do.call(rbind, lapply(setdiff(all_nodes, "ROOT"), \(node) {
    parts  <- strsplit(node, "\\.")[[1]]
    parent <- if (length(parts) == 1) "ROOT" else
      paste(parts[-length(parts)], collapse = ".")
    data.frame(from = parent, to = node)
  }))

  node_df <- data.frame(name = all_nodes, stringsAsFactors = FALSE) |>
    left_join(cluster_summary |> select(cluster_id, n, enrichment),
              by = c("name" = "cluster_id")) |>
    mutate(is_leaf = name %in% leaf_paths)

  for (i in seq_len(nrow(node_df))) {
    if (is.na(node_df$n[i])) {
      descs <- leaf_paths[startsWith(leaf_paths, paste0(node_df$name[i], ".")) |
                            leaf_paths == node_df$name[i]]
      node_df$n[i] <- sum(
        cluster_summary$n[cluster_summary$cluster_id %in% descs]
      )
    }
  }
  node_df$enrichment[is.na(node_df$enrichment)] <- ""

  g <- tbl_graph(nodes = node_df, edges = edges, directed = TRUE)
  list(graph = g, node_df = node_df, cluster_summary = cluster_summary)
}

plot_bhs_tree <- function(tree_info, title, max_sz = 15) {
  set.seed(42)
  ggraph(tree_info$graph, layout = "tree", circular = FALSE) +
    geom_edge_diagonal(colour = "grey50", width = 0.4) +
    geom_node_point(aes(filter = !is_leaf),
                    colour = "grey60", size = 1.5) +
    geom_node_point(aes(filter = is_leaf, size = n,
                        colour = enrichment)) +
    geom_node_text(
      aes(filter = is_leaf,
          label = paste0(name, "\n(", n, ")")),
      size = 2.0, vjust = -0.8, lineheight = 0.85
    ) +
    scale_size_area(max_size = max_sz, guide = "none") +
    scale_colour_manual(values = enrich_colours, breaks = enrich_levels,
                        na.value = "grey70", name = "Top enrichment") +
    theme_void() +
    theme(legend.position = "bottom",
          plot.title = element_text(size = 12, face = "bold",
                                    hjust = 0.5)) +
    labs(title = title)
}
```


## Tree structure comparison

```{r build-trees}
extra <- if (has_annotations) {
  list("Rpn4 target" = rpn4, "Gcn4 target" = gcn4,
       "Sum1 target" = sum1)
} else NULL

tree_a <- build_bhs_tree(clust_a, cats, extra)
tree_b <- build_bhs_tree(clust_b, cats, extra)
```

```{r side-by-side-trees, fig.width=14, fig.height=7}
p_a <- plot_bhs_tree(tree_a, params$label_a)
p_b <- plot_bhs_tree(tree_b, params$label_b)

(p_a | p_b) +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom")
```

```{r tree-summary}
bind_rows(
  tree_a$cluster_summary |> mutate(source = params$label_a),
  tree_b$cluster_summary |> mutate(source = params$label_b)
) |>
  group_by(source) |>
  summarise(
    clusters  = n(),
    min_size  = min(n),
    median_size = median(n),
    max_size  = max(n),
    max_depth = max(depth),
    .groups = "drop"
  ) |>
  gt() |>
  tab_header(title = "Structural summary") |>
  cols_label(source = "Clustering")
```


## Contingency heatmap

A cross-tabulation of cluster assignments.
Perfect agreement produces a diagonal; off-diagonal mass indicates
redistribution of genes between clusters.

```{r contingency-heatmap, fig.width=10, fig.height=8}
ctab   <- table(combined$cluster_a, combined$cluster_b)
ctab_df <- as.data.frame.table(ctab, stringsAsFactors = FALSE) |>
  rename(cluster_a = Var1, cluster_b = Var2, count = Freq) |>
  mutate(
    cluster_a = factor(cluster_a, levels = sort(unique(cluster_a))),
    cluster_b = factor(cluster_b, levels = sort(unique(cluster_b)))
  )

ggplot(ctab_df, aes(x = cluster_b, y = cluster_a, fill = count)) +
  geom_tile(colour = "white", linewidth = 0.3) +
  geom_text(aes(label = ifelse(count > 0, count, "")),
            size = 2.5, colour = "grey20") +
  scale_fill_gradient(low = "white", high = "#2166ac",
                      name = "Gene count", trans = "sqrt") +
  scale_x_discrete(position = "top") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 0,
                                family = "mono", size = 7),
    axis.text.y = element_text(family = "mono", size = 7),
    panel.grid  = element_blank(),
    plot.title  = element_text(size = 13, face = "bold")
  ) +
  labs(
    title = paste0("Cluster cross-tabulation"),
    x = params$label_b, y = params$label_a
  )
```


## Alluvial diagram

Gene flow from `r params$label_a` clusters to `r params$label_b` clusters.
Small flows (< `r max(5, round(n_shared * 0.002))` genes) are omitted
for clarity.

```{r alluvial, fig.width=10, fig.height=8}
flow_thresh <- max(5, round(n_shared * 0.002))

alluvial_df <- combined |>
  count(cluster_a, cluster_b, name = "n") |>
  filter(n >= flow_thresh) |>
  mutate(
    cluster_a = factor(cluster_a, levels = sort(unique(cluster_a))),
    cluster_b = factor(cluster_b, levels = sort(unique(cluster_b)))
  )

n_a_colours <- n_distinct(alluvial_df$cluster_a)

ggplot(alluvial_df,
       aes(y = n, axis1 = cluster_a, axis2 = cluster_b)) +
  geom_alluvium(aes(fill = cluster_a), width = 1/5, alpha = 0.6) +
  geom_stratum(width = 1/5, fill = "grey90", colour = "grey50") +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)),
            size = 2.2, family = "mono") +
  scale_x_discrete(limits = c(params$label_a, params$label_b),
                   expand = c(0.15, 0.05)) +
  scale_fill_manual(
    values = hue_pal()(n_a_colours),
    guide  = "none"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks  = element_blank(),
    panel.grid  = element_blank(),
    plot.title  = element_text(size = 13, face = "bold")
  ) +
  labs(
    title = "Gene flow between clusterings",
    subtitle = paste0("Flows with >= ", flow_thresh, " genes shown"),
    y = "Gene count"
  )
```


## Quantitative agreement

```{r agreement-metrics}
ari_val <- ARI(combined$cluster_a, combined$cluster_b)
nmi_val <- NMI(combined$cluster_a, combined$cluster_b)
ami_val <- AMI(combined$cluster_a, combined$cluster_b)

interp <- function(x) {
  case_when(
    x > 0.9  ~ "Near-identical",
    x > 0.7  ~ "Strong agreement",
    x > 0.5  ~ "Moderate agreement",
    x > 0.25 ~ "Weak agreement",
    TRUE      ~ "Poor / near-random"
  )
}

tibble(
  Metric = c("Adjusted Rand Index (ARI)",
             "Normalized Mutual Information (NMI)",
             "Adjusted Mutual Information (AMI)"),
  Value  = c(ari_val, nmi_val, ami_val),
  Interpretation = interp(c(ari_val, nmi_val, ami_val))
) |>
  gt() |>
  fmt_number(columns = Value, decimals = 4) |>
  tab_header(title = "Clustering agreement metrics")
```


## Cluster purity

For each cluster in one clustering, the table shows the two largest
overlapping clusters in the other, with gene counts and percentages.

```{r purity-helper}
purity_table <- function(df, from_col, to_col, from_label, to_label) {
  tbl <- df |>
    count({{ from_col }}, {{ to_col }}, name = "n_overlap") |>
    group_by({{ from_col }}) |>
    mutate(n_total = sum(n_overlap),
           pct     = 100 * n_overlap / n_total) |>
    slice_max(n_overlap, n = 2, with_ties = FALSE) |>
    mutate(rank = row_number()) |>
    ungroup() |>
    mutate(label = sprintf("%s (%d, %.0f%%)",
                           {{ to_col }}, n_overlap, pct)) |>
    select({{ from_col }}, n_total, rank, label) |>
    pivot_wider(names_from = rank, values_from = label,
                names_prefix = "overlap_") |>
    arrange({{ from_col }})

  # Rename columns before passing to gt (avoids formula eval issues)
  # setNames: new_name = old_name for dplyr::rename
  col1 <- names(tbl)[1]
  rename_map <- setNames(
    c(col1, "n_total", "overlap_1", "overlap_2"),
    c(from_label, "N",
      paste("Largest in", to_label),
      paste("2nd largest in", to_label))
  )
  # Only rename columns that exist (overlap_2 may be absent)
  rename_map <- rename_map[rename_map %in% names(tbl)]
  tbl <- rename(tbl, !!!rename_map)
  gt(tbl)
}
```

### `r params$label_a` &rarr; `r params$label_b`

```{r purity-a-to-b}
purity_table(combined, cluster_a, cluster_b,
             params$label_a, params$label_b) |>
  tab_header(title = paste0("Where do ", params$label_a,
                             " clusters map in ", params$label_b, "?"))
```

### `r params$label_b` &rarr; `r params$label_a`

```{r purity-b-to-a}
purity_table(combined, cluster_b, cluster_a,
             params$label_b, params$label_a) |>
  tab_header(title = paste0("Where do ", params$label_b,
                             " clusters map in ", params$label_a, "?"))
```


## Gene-pair co-clustering stability

All metrics are computed from the contingency table without enumerating
gene pairs.

```{r pair-stability}
n_ij      <- as.matrix(ctab)
n         <- sum(n_ij)
total_pairs <- choose(n, 2)

# Pairs co-clustered in both A and B
a <- sum(choose(n_ij, 2))

# Pairs co-clustered in A (any B)
row_sums <- rowSums(n_ij)
b_plus_a <- sum(choose(row_sums, 2))

# Pairs co-clustered in B (any A)
col_sums <- colSums(n_ij)
c_plus_a <- sum(choose(col_sums, 2))

# Pairs separated in both
d <- total_pairs - b_plus_a - c_plus_a + a

pair_agreement    <- (a + d) / total_pairs
co_stab_a_to_b    <- if (b_plus_a > 0) a / b_plus_a else NA_real_
co_stab_b_to_a    <- if (c_plus_a > 0) a / c_plus_a else NA_real_

tibble(
  Metric = c(
    "Total gene pairs",
    "Pairs co-clustered in both",
    "Pairs separated in both",
    paste("Pairs co-clustered only in", params$label_a),
    paste("Pairs co-clustered only in", params$label_b),
    "Pair agreement rate (Rand Index)",
    paste0("Co-clustering stability (",
           params$label_a, " \u2192 ", params$label_b, ")"),
    paste0("Co-clustering stability (",
           params$label_b, " \u2192 ", params$label_a, ")")
  ),
  Value = c(
    formatC(total_pairs, format = "d", big.mark = ","),
    formatC(a, format = "d", big.mark = ","),
    formatC(d, format = "d", big.mark = ","),
    formatC(b_plus_a - a, format = "d", big.mark = ","),
    formatC(c_plus_a - a, format = "d", big.mark = ","),
    sprintf("%.4f", pair_agreement),
    sprintf("%.4f", co_stab_a_to_b),
    sprintf("%.4f", co_stab_b_to_a)
  )
) |>
  gt() |>
  tab_header(title = "Gene-pair co-clustering analysis")
```


## Summary

`r params$label_a` (`r n_distinct(combined$cluster_a)` clusters) vs
`r params$label_b` (`r n_distinct(combined$cluster_b)` clusters) over
`r format(n_shared, big.mark = ",")` shared genes.
**ARI = `r sprintf("%.3f", ari_val)`**
(`r interp(ari_val)`),
**NMI = `r sprintf("%.3f", nmi_val)`**.
Gene-pair agreement rate (Rand Index): `r sprintf("%.3f", pair_agreement)`.
